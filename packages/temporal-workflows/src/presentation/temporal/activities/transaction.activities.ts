/**
 * Transaction Activities (Layer 3 - Interface Adapters / Controllers)
 * Activities are Controllers in Clean Architecture
 * Handle transaction extraction and persistence
 */
import { Context } from '@temporalio/activity';
import { DependencyContainer } from 'tsyringe';

// Gateways (Application Layer Interfaces)
import { ITransactionExtractorGateway } from '../../../application/interfaces/gateways/iai-gateway';
import { ITransactionRepository } from '../../../application/interfaces/repositories/itransaction-repository';

// Domain Entities
import { Email } from '../../../domain/entities/email.entity';
import { Transaction } from '../../../domain/entities/transaction.entity';

// Shared Types (for Temporal compatibility)
import {
  ExtractTransactionInput,
  ExtractedTransaction,
  SaveTransactionInput,
  SavedTransaction
} from '../../../shared/types';

/**
 * Create Transaction Activities using DI Container
 * Activities orchestrate AI extraction and transaction persistence
 */
export function createTransactionActivities(container: DependencyContainer) {
  // Resolve dependencies from DI Container
  const extractorGateway = container.resolve<ITransactionExtractorGateway>('ITransactionExtractorGateway');
  const transactionRepository = container.resolve<ITransactionRepository>('ITransactionRepository');

  return {
    /**
     * Extract transaction from email using AI
     * Delegates to AI gateway (OpenAI or Ollama based on configuration)
     */
    async extractTransactionFromEmail(input: ExtractTransactionInput): Promise<ExtractedTransaction> {
      Context.current().heartbeat();

      // Create domain Email entity from input
      const email = new Email(
        input.emailId || '',
        input.emailFrom,
        input.emailSubject,
        input.emailContent,
        input.emailDate,
        ''  // ThreadId not needed for extraction
      );

      // Use AI gateway to extract transaction (provider-agnostic)
      const transaction = await extractorGateway.extractTransaction(email, {
        extractionPrompt: input.extractionPrompt,
        bankName: input.bankName
      });

      // Map domain Transaction to Temporal-compatible format
      return {
        transactionDate: transaction.transactionDate,
        merchant: transaction.merchant,
        amount: transaction.amount,
        currency: transaction.currency,
        category: transaction.category,
        transactionType: transaction.transactionType,
        accountNumber: transaction.accountNumber,
        confidence: transaction.confidence,
        rawResponse: transaction.rawData || {}
      };
    },

    /**
     * Save transaction to repository
     * Maps from Temporal types to domain entities
     */
    async saveTransaction(input: SaveTransactionInput): Promise<SavedTransaction> {
      Context.current().heartbeat();

      // Create domain Transaction entity from input
      const transaction = new Transaction(
        '',  // ID will be generated by repository
        input.emailId,
        input.extractedData.transactionDate,
        input.extractedData.merchant,
        input.extractedData.amount,
        input.extractedData.currency,
        input.extractedData.category,
        input.extractedData.transactionType,
        input.extractedData.accountNumber,
        input.extractedData.confidence,
        '',  // BankName - will be set from pattern
        input.extractedData.subcategory,
        input.extractedData.rawResponse
      );

      // Save through repository
      const savedTransaction = await transactionRepository.save(transaction);

      // Map to Temporal-compatible format
      return {
        id: savedTransaction.id,
        emailId: savedTransaction.emailId,
        transactionDate: savedTransaction.transactionDate,
        merchant: savedTransaction.merchant,
        amount: savedTransaction.amount,
        category: savedTransaction.category
      };
    },

    /**
     * Find transaction by email ID
     * Delegates to repository
     */
    async findTransactionByEmailId(emailId: string): Promise<SavedTransaction | null> {
      Context.current().heartbeat();

      const transaction = await transactionRepository.findByEmailId(emailId);

      if (!transaction) {
        return null;
      }

      // Map to Temporal-compatible format
      return {
        id: transaction.id,
        emailId: transaction.emailId,
        transactionDate: transaction.transactionDate,
        merchant: transaction.merchant,
        amount: transaction.amount,
        category: transaction.category
      };
    },

    /**
     * Check if transaction exists for email
     * Delegates to repository
     */
    async transactionExistsForEmail(emailId: string): Promise<boolean> {
      Context.current().heartbeat();

      const transaction = await transactionRepository.findByEmailId(emailId);
      return transaction !== null;
    }
  };
}
